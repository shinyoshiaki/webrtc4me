{"version":3,"file":"arraybuffer.js","sourceRoot":"","sources":["../../src/utill/arraybuffer.ts"],"names":[],"mappings":";;AAAA,SAAgB,gBAAgB,CAC9B,WAAwB,EACxB,WAAmB;IAEnB,IAAM,QAAQ,GAAkB,EAAE,CAAC;IACnC,IAAI,EAAE,GAAG,CAAC,CAAC;IACX,OAAO,EAAE,GAAG,WAAW,GAAG,WAAW,CAAC,UAAU,EAAE;QAChD,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,GAAG,WAAW,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC;QAC3E,EAAE,EAAE,CAAC;KACN;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAXD,4CAWC;AAED,SAAgB,gBAAgB,CAAC,QAAuB;IACtD,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;QACxC,SAAS,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;KACrC;IACD,IAAI,KAAK,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;IACtC,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;QACxC,KAAK,CAAC,GAAG,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QAC5C,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;KAC/B;IACD,OAAO,KAAK,CAAC,MAAqB,CAAC;AACrC,CAAC;AAZD,4CAYC;AAEY,QAAA,gBAAgB,GAAG,UAAC,IAAU;IACzC,OAAA,IAAI,OAAO,CAAc,UAAC,OAAO,EAAE,MAAM;QACvC,IAAM,CAAC,GAAG,IAAI,UAAU,EAAE,CAAC;QAC3B,CAAC,CAAC,OAAO,GAAG,UAAA,CAAC,IAAI,OAAA,MAAM,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC;QAC3B,CAAC,CAAC,MAAM,GAAG,UAAA,CAAC,IAAI,OAAA,OAAO,CAAE,CAAC,CAAC,MAAc,CAAC,MAAM,CAAC,EAAjC,CAAiC,CAAC;QAClD,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC;AALF,CAKE,CAAC","sourcesContent":["export function sliceArraybuffer(\n  arrayBuffer: ArrayBuffer,\n  segmentSize: number\n) {\n  const segments: ArrayBuffer[] = [];\n  let fi = 0;\n  while (fi * segmentSize < arrayBuffer.byteLength) {\n    segments.push(arrayBuffer.slice(fi * segmentSize, (fi + 1) * segmentSize));\n    ++fi;\n  }\n  return segments;\n}\n\nexport function mergeArraybuffer(segments: ArrayBuffer[]) {\n  let sumLength = 0;\n  for (let i = 0; i < segments.length; ++i) {\n    sumLength += segments[i].byteLength;\n  }\n  let whole = new Uint8Array(sumLength);\n  let pos = 0;\n  for (let i = 0; i < segments.length; ++i) {\n    whole.set(new Uint8Array(segments[i]), pos);\n    pos += segments[i].byteLength;\n  }\n  return whole.buffer as ArrayBuffer;\n}\n\nexport const blob2Arraybuffer = (blob: Blob) =>\n  new Promise<ArrayBuffer>((resolve, reject) => {\n    const r = new FileReader();\n    r.onerror = e => reject(e);\n    r.onload = e => resolve((e.target as any).result);\n    r.readAsArrayBuffer(blob);\n  });\n"]}