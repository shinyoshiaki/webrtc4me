{"version":3,"file":"file.js","sourceRoot":"","sources":["../../src/modules/file.ts"],"names":[],"mappings":"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","sourcesContent":["import WebRTC from \"../core\";\nimport Event from \"rx.mini\";\n\nconst chunkSize = 16000;\n\nexport default class FileShare {\n  private chunks: ArrayBuffer[] = [];\n  private name: string = \"\";\n  private size: number = 0;\n  event = new Event<Actions>();\n\n  constructor(private peer: WebRTC, private label?: string) {\n    if (!label) label = \"file\";\n    peer.onData.subscribe(({ label, data, dataType }) => {\n      if (label === this.label) {\n        if (dataType === \"string\") {\n          const obj = JSON.parse(data as any);\n          switch (obj.state) {\n            case \"start\":\n              this.chunks = [];\n              this.name = obj.name;\n              this.size = obj.size;\n              break;\n            case \"end\":\n              this.event.execute(Downloaded(this.chunks, this.name));\n              peer.send(\n                JSON.stringify({ state: \"complete\", name: this.name }),\n                this.label\n              );\n              this.chunks = [];\n              this.name = \"\";\n              break;\n          }\n        } else if (dataType === \"ArrayBuffer\") {\n          this.chunks.push(data as any);\n          this.event.execute(\n            Downloading(this.chunks.length * chunkSize, this.size)\n          );\n        }\n      }\n    });\n  }\n\n  private sendStart(name: string, size: number) {\n    this.name = name;\n    this.peer.send(JSON.stringify({ state: \"start\", size, name }), this.label);\n  }\n\n  private sendChunk(chunk: ArrayBuffer) {\n    this.peer.send(chunk, this.label);\n  }\n\n  private sendEnd() {\n    this.peer.send(JSON.stringify({ state: \"end\" }), this.label);\n  }\n\n  send(blob: File) {\n    this.sendStart(blob.name, blob.size);\n    getSliceArrayBuffer(blob).subscribe(\n      chunk => this.sendChunk(chunk),\n      () => this.sendEnd()\n    );\n  }\n}\n\nfunction getSliceArrayBuffer(blob: Blob) {\n  const subject = new Event<ArrayBuffer>();\n\n  const r = new FileReader(),\n    blobSlice = File.prototype.slice,\n    chunknum = Math.ceil(blob.size / chunkSize);\n  let currentChunk = 0;\n  r.onerror = e => {\n    subject.error(e);\n  };\n  r.onload = e => {\n    const chunk = (e.target as any).result;\n    currentChunk++;\n    if (currentChunk <= chunknum) {\n      loadNext();\n      subject.execute(chunk);\n    } else {\n      subject.complete();\n    }\n  };\n  function loadNext() {\n    const start = currentChunk * chunkSize;\n    const end = start + chunkSize >= blob.size ? blob.size : start + chunkSize;\n    r.readAsArrayBuffer(blobSlice.call(blob, start, end));\n  }\n  loadNext();\n\n  return subject;\n}\n\nconst Downloading = (now: number, size: number) => ({\n  type: \"downloading\" as const,\n  payload: { now, size }\n});\n\nconst Downloaded = (chunks: ArrayBuffer[], name: string) => ({\n  type: \"downloaded\" as const,\n  payload: { chunks, name }\n});\n\ntype Actions = ReturnType<typeof Downloading> | ReturnType<typeof Downloaded>;\n"]}