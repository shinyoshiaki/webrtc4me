{"version":3,"file":"file.js","sourceRoot":"","sources":["../../src/modules/file.ts"],"names":[],"mappings":"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","sourcesContent":["import WebRTC from \"../core\";\nimport { Subject, Observable } from \"rxjs\";\nimport Event from \"rx.mini\";\n\nconst chunkSize = 16000;\n\nexport function getSliceArrayBuffer(blob: Blob): Observable<any> {\n  const subject = new Subject<Actions>();\n  const state = subject.asObservable();\n\n  const r = new FileReader(),\n    blobSlice = File.prototype.slice,\n    chunknum = Math.ceil(blob.size / chunkSize);\n  let currentChunk = 0;\n  r.onerror = e => {\n    subject.error(e);\n  };\n  r.onload = e => {\n    const chunk = (e.target as any).result;\n    currentChunk++;\n    if (currentChunk <= chunknum) {\n      loadNext();\n      subject.next(chunk);\n    } else {\n      subject.complete();\n    }\n  };\n  function loadNext() {\n    const start = currentChunk * chunkSize;\n    const end = start + chunkSize >= blob.size ? blob.size : start + chunkSize;\n    r.readAsArrayBuffer(blobSlice.call(blob, start, end));\n  }\n  loadNext();\n  return state;\n}\n\nconst Downloading = (now: number, size: number) => {\n  return {\n    type: \"downloading\" as const,\n    payload: { now, size }\n  };\n};\n\nconst Downloaded = (chunks: ArrayBuffer[], name: string) => {\n  return {\n    type: \"downloaded\" as const,\n    payload: { chunks, name }\n  };\n};\n\ntype Actions = ReturnType<typeof Downloading> | ReturnType<typeof Downloaded>;\n\nexport default class FileShare {\n  private chunks: ArrayBuffer[] = [];\n  private name: string = \"\";\n  private size: number = 0;\n  event = new Event<Actions>();\n\n  constructor(private peer: WebRTC, private label?: string) {\n    if (!label) label = \"file\";\n    peer.onData.subscribe(raw => {\n      const { label, data } = raw;\n      if (label === this.label) {\n        try {\n          const obj = JSON.parse(data);\n          switch (obj.state) {\n            case \"start\":\n              this.chunks = [];\n              this.name = obj.name;\n              this.size = obj.size;\n              break;\n            case \"end\":\n              this.event.execute(Downloaded(this.chunks, this.name));\n              peer.send(\n                JSON.stringify({ state: \"complete\", name: this.name }),\n                this.label\n              );\n              this.chunks = [];\n              this.name = \"\";\n              break;\n          }\n        } catch (error) {\n          this.chunks.push(data);\n          this.event.execute(Downloading(this.chunks.length, this.size));\n        }\n      }\n    });\n  }\n\n  private sendStart(name: string, size: number) {\n    this.name = name;\n    this.peer.send(JSON.stringify({ state: \"start\", size, name }), this.label);\n  }\n\n  private sendChunk(chunk: ArrayBuffer) {\n    this.peer.send(chunk, this.label);\n  }\n\n  private sendEnd() {\n    this.peer.send(JSON.stringify({ state: \"end\" }), this.label);\n  }\n\n  send(blob: File) {\n    this.sendStart(blob.name, blob.size);\n    getSliceArrayBuffer(blob).subscribe(\n      chunk => this.sendChunk(chunk),\n      () => {},\n      () => this.sendEnd()\n    );\n  }\n}\n"]}