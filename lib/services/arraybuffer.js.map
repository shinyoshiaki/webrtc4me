{"version":3,"file":"arraybuffer.js","sourceRoot":"","sources":["../../src/services/arraybuffer.ts"],"names":[],"mappings":"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","sourcesContent":["import { mergeArraybuffer, sliceArraybuffer } from \"../utill/arraybuffer\";\n\nimport Event from \"rx.mini\";\nimport WebRTC from \"../core\";\n\nexport default class ArrayBufferService {\n  private label = \"wrtc4me_abservice\";\n\n  private memory: ArrayBuffer[] = [];\n\n  private onData = new Event<MessageEvent>();\n\n  constructor(private peer: WebRTC) {\n    this.listen();\n  }\n\n  listen = async () => {\n    const { peer } = this;\n\n    await peer.onConnect.asPromise();\n\n    peer.onOpenDC.subscribe(dc => {\n      if (dc.label === this.label) {\n        dc.onmessage = this.onData.execute;\n      }\n    });\n\n    const { unSubscribe } = this.onData.subscribe(({ data }) => {\n      if (typeof data === \"string\") {\n        const { type, payload } = JSON.parse(data);\n        switch (type) {\n          case \"end\": {\n            const ab = mergeArraybuffer(Object.values(this.memory));\n            peer.onData.execute({\n              label: payload,\n              data: ab,\n              nodeId: peer.nodeId,\n              dataType: \"ArrayBuffer\"\n            });\n            this.memory = [];\n          }\n        }\n      } else {\n        this.memory.push(data);\n      }\n    });\n\n    peer.onDisconnect.once(unSubscribe);\n  };\n\n  send = async (ab: ArrayBuffer, label: string) => {\n    const dc = await this.createDC();\n\n    const chunks = sliceArraybuffer(ab, 16 * 1000);\n\n    await this.job(chunks, dc);\n\n    this.rpc({ type: \"end\", payload: label }, dc);\n  };\n\n  private job = async (chunks: ArrayBuffer[], dc: RTCDataChannel) => {\n    for (let i = 0; i < chunks.length; ) {\n      if (dc.bufferedAmount > 1024 * 1000) {\n        await new Promise(r => setTimeout(r));\n        continue;\n      }\n      const chunk = chunks[i];\n      try {\n        dc.send(chunk);\n        i++;\n      } catch (error) {\n        console.warn({ error });\n      }\n    }\n  };\n\n  private rpc = async (\n    msg: { type: string; payload: any },\n    dc: RTCDataChannel\n  ) => {\n    try {\n      dc.send(JSON.stringify(msg));\n    } catch (error) {\n      console.warn({ error });\n    }\n  };\n\n  private createDC = async () => {\n    const dc = this.peer.rtc.createDataChannel(this.label);\n    await new Promise(r => (dc.onopen = () => r()));\n    return dc;\n  };\n}\n"]}