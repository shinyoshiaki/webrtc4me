{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/services/arraybuffer/index.ts"],"names":[],"mappings":";;;AACA,uDAA6E;AAE7E;IAAA;QAAA,iBAwDC;QAvDC,UAAK,GAAG,WAAW,CAAC;QACZ,WAAM,GAAG,aAAa,CAAC;QAEvB,WAAM,GAAkB,EAAE,CAAC;QAsBnC,mBAAmB;QACnB,SAAI,GAAG,UACL,EAAe,EACf,MAAc,EACd,EAAkB,EAClB,EAAqB;;;;;wBAErB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;wBACf,MAAM,GAAG,8BAAgB,CAAC,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,CAAC;4CACtC,CAAC;;;;;6CACJ,CAAA,EAAE,CAAC,UAAU,KAAK,MAAM,CAAA,EAAxB,wBAAwB;;;;wCAElB,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;wCACxB,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wCACf,CAAC,EAAE,CAAC;;;;wCAEJ,qBAAM,IAAI,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,EAAhB,CAAgB,CAAC,EAAA;;wCAAxC,SAAwC,CAAC;;;;6CAElC,CAAA,EAAE,CAAC,UAAU,KAAK,QAAQ,CAAA,EAA1B,wBAA0B;wCAC7B,SAAO,EAAE,CAAC,iBAAiB,CAAC,OAAK,KAAK,CAAC,CAAC;wCAC9C,qBAAM,IAAI,OAAO,CAAC,UAAA,OAAO;gDACvB,MAAI,CAAC,MAAM,GAAG;oDACZ,OAAO,EAAE,CAAC;gDACZ,CAAC,CAAC;4CACJ,CAAC,CAAC,EAAA;;wCAJF,SAIE,CAAC;wCACH,EAAE,GAAG,MAAI,CAAC;;;kDAhBL,CAAC;;;;;;wBAAD,CAAC,GAAG,CAAC;;;6BAAE,CAAA,CAAC,GAAG,MAAM,CAAC,MAAM,CAAA;sDAAxB,CAAC;;;wBAAD,CAAC;;;;wBAmBV,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;;;;aACjB,CAAC;IACJ,CAAC;IAlDC,mCAAM,GAAN,UAAO,IAAY;QAAnB,iBAkBC;QAjBC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,UAAA,GAAG;YACvB,IAAI,GAAG,CAAC,KAAK,KAAK,KAAI,CAAC,KAAK,EAAE;gBAC5B,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;gBACtB,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;oBAC5B,IAAM,EAAE,GAAG,8BAAgB,CAAC,KAAI,CAAC,MAAM,CAAC,CAAC;oBACzC,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAI,CAAC,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC7C,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC;wBAClB,KAAK,EAAE,IAAI;wBACX,IAAI,EAAE,EAAE;wBACR,MAAM,EAAE,IAAI,CAAC,MAAM;qBACpB,CAAC,CAAC;oBACH,KAAI,CAAC,MAAM,GAAG,EAAE,CAAC;iBAClB;qBAAM;oBACL,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBACxB;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAgCH,yBAAC;AAAD,CAAC,AAxDD,IAwDC","sourcesContent":["import WebRTC from \"../../core\";\nimport { mergeArraybuffer, sliceArraybuffer } from \"../../utill/arraybuffer\";\n\nexport default class ArrayBufferService {\n  label = \"w4me_file\";\n  private origin = \"datachannel\";\n\n  private memory: ArrayBuffer[] = [];\n\n  listen(peer: WebRTC) {\n    peer.onData.subscribe(msg => {\n      if (msg.label === this.label) {\n        const data = msg.data;\n        if (typeof data === \"string\") {\n          const ab = mergeArraybuffer(this.memory);\n          console.log(\"finish\", this.memory, msg.data);\n          peer.onData.execute({\n            label: data,\n            data: ab,\n            nodeId: peer.nodeId\n          });\n          this.memory = [];\n        } else {\n          this.memory.push(data);\n        }\n      }\n    });\n  }\n\n  // TODO test on kad\n  send = async (\n    ab: ArrayBuffer,\n    origin: string,\n    dc: RTCDataChannel,\n    pc: RTCPeerConnection\n  ) => {\n    this.origin = origin;\n    const chunks = sliceArraybuffer(ab, 16 * 1000);\n    for (let i = 0; i < chunks.length; ) {\n      if (dc.readyState === \"open\") {\n        try {\n          const chunk = chunks[i];\n          dc.send(chunk);\n          i++;\n        } catch (error) {\n          await new Promise(r => setTimeout(r, 0));\n        }\n      } else if (dc.readyState === \"closed\") {\n        const make = pc.createDataChannel(this.label);\n        await new Promise(resolve => {\n          make.onopen = () => {\n            resolve();\n          };\n        });\n        dc = make;\n      }\n    }\n    dc.send(origin);\n  };\n}\n"]}