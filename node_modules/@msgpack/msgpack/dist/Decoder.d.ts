declare enum State {
    ARRAY = 0,
    MAP_KEY = 1,
    MAP_VALUE = 2
}
declare type StackMapState = {
    type: State.MAP_KEY | State.MAP_VALUE;
    size: number;
    key: string | null;
    readCount: number;
    map: Record<string, unknown>;
};
declare type StackArrayState = {
    type: State.ARRAY;
    size: number;
    array: Array<unknown>;
    position: number;
};
declare type StackState = StackArrayState | StackMapState;
export declare const DataViewIndexOutOfBoundsError: typeof Error;
export declare class Decoder {
    readonly extensionCodec: import("./ExtensionCodec").ExtensionCodecType;
    readonly maxStrLength: number;
    readonly maxBinLength: number;
    readonly maxArrayLength: number;
    readonly maxMapLength: number;
    readonly maxExtLength: number;
    totalPos: number;
    pos: number;
    view: DataView;
    bytes: Uint8Array;
    headByte: number;
    readonly stack: Array<StackState>;
    constructor(extensionCodec?: import("./ExtensionCodec").ExtensionCodecType, maxStrLength?: number, maxBinLength?: number, maxArrayLength?: number, maxMapLength?: number, maxExtLength?: number);
    setBuffer(buffer: ArrayLike<number> | ArrayBuffer): void;
    appendBuffer(buffer: ArrayLike<number>): void;
    hasRemaining(size?: number): boolean;
    createNoExtraBytesError(posToShow: number): RangeError;
    decodeOneSync(): unknown;
    decodeOneAsync(stream: AsyncIterable<ArrayLike<number>>): Promise<unknown>;
    decodeStream(stream: AsyncIterable<ArrayLike<number>>): AsyncIterableIterator<unknown>;
    decodeArrayStream(stream: AsyncIterable<ArrayLike<number>>): AsyncIterableIterator<unknown>;
    decodeSync(): unknown;
    readHeadByte(): number;
    complete(): void;
    readArraySize(): number;
    pushMapState(size: number): void;
    pushArrayState(size: number): void;
    decodeUtf8String(byteLength: number, headerOffset: number): string;
    decodeBinary(byteLength: number, headOffset: number): Uint8Array;
    decodeExtension(size: number, headOffset: number): unknown;
    lookU8(): number;
    lookU16(): number;
    lookU32(): number;
    readU8(): number;
    readI8(): number;
    readU16(): number;
    readI16(): number;
    readU32(): number;
    readI32(): number;
    readU64(): number;
    readI64(): number;
    readF32(): number;
    readF64(): number;
}
export {};
