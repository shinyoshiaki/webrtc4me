"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// WASM=never - disable WASM functions
// WASM=force - force to use WASM functions
const WASM = process.env.MSGPACK_WASM || process.env.WASM || "";
exports.NO_WASM = WASM === "never";
exports.FORCE_WASM = WASM === "force";
// WM stands for WasmModule, but not the WebAssembly.Module instance but the WebAssembly.Instance.prototype.exports
const wm = (() => {
    if (exports.NO_WASM) {
        return null;
    }
    try {
        return require("../dist/wasm/msgpack.wasm.js");
    }
    catch (e) {
        if (exports.FORCE_WASM) {
            throw e;
        }
        return null;
    }
})();
exports.WASM_AVAILABLE = !!wm;
// A hint of when to use WASM ver.
exports.WASM_STR_THRESHOLD = exports.FORCE_WASM ? 0 : 1024;
function setMemoryU8(destPtr, src, size) {
    const destView = new Uint8Array(wm.memory.buffer, destPtr, size);
    destView.set(src);
}
function setMemoryStr(destPtr, destByteLength, str, strLength) {
    const inputView = new DataView(wm.memory.buffer, destPtr, destByteLength);
    for (let i = 0; i < strLength; i++) {
        inputView.setUint16(i * 2, str.charCodeAt(i));
    }
}
/**
 * It encodes string to MessagePack str family (headByte/size + utf8 bytes).
 * @returns The whole byte length including headByte/size.
 */
function utf8EncodeWasm(str, output, outputOffset) {
    const strLength = str.length;
    const inputByteLength = strLength * 2;
    const inputU16BePtr = wm.malloc(inputByteLength);
    setMemoryStr(inputU16BePtr, inputByteLength, str, strLength);
    const maxOutputHeaderSize = 1 + 4; // headByte + u32
    const outputPtr = wm.malloc(maxOutputHeaderSize + strLength * 4);
    try {
        const outputLength = wm.utf8EncodeUint16Array(outputPtr, inputU16BePtr, strLength);
        output.set(new Uint8Array(wm.memory.buffer, outputPtr, outputLength), outputOffset);
        return outputLength;
    }
    finally {
        wm.free(inputU16BePtr);
        wm.free(outputPtr);
    }
}
exports.utf8EncodeWasm = utf8EncodeWasm;
const CHUNK_SIZE = 65536;
function safeStringFromCharCodeU16(units) {
    if (units.length <= CHUNK_SIZE) {
        // `String.fromCharCode.apply()` is faster than `String.fromCharCode(...units)`
        // in case `units` is a typed array
        return String.fromCharCode.apply(String, units);
    }
    let result = "";
    for (let i = 0; i < units.length; i++) {
        const chunk = units.subarray(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
        result += String.fromCharCode.apply(String, chunk);
    }
    return result;
}
// A wrapper function for utf8DecodeToUint16Array()
function utf8DecodeWasm(bytes, inputOffset, byteLength) {
    const inputPtr = wm.malloc(byteLength);
    // in worst case, the UTF-16 array uses the same as byteLength * 2
    const outputPtr = wm.malloc(byteLength * 2);
    try {
        setMemoryU8(inputPtr, bytes.subarray(inputOffset, inputOffset + byteLength), byteLength);
        const outputArraySize = wm.utf8DecodeToUint16Array(outputPtr, inputPtr, byteLength);
        const units = new Uint16Array(wm.memory.buffer, outputPtr, outputArraySize);
        return safeStringFromCharCodeU16(units);
    }
    finally {
        wm.free(inputPtr);
        wm.free(outputPtr);
    }
}
exports.utf8DecodeWasm = utf8DecodeWasm;
//# sourceMappingURL=wasmFunctions.js.map