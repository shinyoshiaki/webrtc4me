{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/tlsf.ts","assembly/utf8DecodeToUint16Array.ts","assembly/utf8EncodeUint16Array.ts","assembly/utf8CountUint16Array.ts","assembly/be.ts","~lib/polyfills.ts","assembly/memory.ts","~lib/memory.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\n@inline export const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Two-Level Segregate Fit Memory Allocator.\n *\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\n * Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/tlsf\n *//***/\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nimport {\n  AL_BITS,\n  AL_SIZE,\n  AL_MASK\n} from \"../internal/allocator\";\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐ info\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      let left: Block = assert(block.left); // can't be null\n      let leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        let slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      let flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      let spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      let right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// Memory allocator interface\n\n/** Allocates a chunk of memory. */\n@global export function __memory_allocate(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n  }\n\n  // search for a suitable block\n  if (size > Block.MAX_SIZE) unreachable();\n\n  // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\n  size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n  var block = root.search(size);\n  if (!block) {\n\n    // request more memory\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n    let pagesAfter = memory.size();\n    root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n    block = assert(root.search(size)); // must be found now\n  }\n\n  assert((block.info & ~TAGS) >= size);\n  return root.use(<Block>block, size);\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global export function __memory_free(data: usize): void {\n  if (data) {\n    let root = ROOT;\n    if (root) {\n      let block = changetype<Block>(data - Block.INFO);\n      let blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\n@global export function __memory_reset(): void {\n  unreachable();\n}\n","export function utf8DecodeToUint16Array(outputPtr: usize, inputPtr: usize, byteLength: usize): usize {\n  let inputOffset = inputPtr;\n  let outputOffset = outputPtr;\n  let inputOffsetEnd = inputOffset + byteLength;\n  const u16s = sizeof<u16>();\n\n  while (inputOffset < inputOffsetEnd) {\n    let byte1: u16 = load<u8>(inputOffset++);\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      store<u16>(outputOffset, byte1);\n      outputOffset += u16s;\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      let byte2: u16 = load<u8>(inputOffset++) & 0x3f;\n      // FIXME: consider endians\n      store<u16>(outputOffset, ((byte1 & 0x1f) << 6) | byte2);\n      outputOffset += u16s;\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      let byte2: u16 = load<u8>(inputOffset++) & 0x3f;\n      let byte3: u16 = load<u8>(inputOffset++) & 0x3f;\n      store<u16>(outputOffset, ((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n      outputOffset += u16s;\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      let byte2 = load<u8>(inputOffset++) & 0x3f;\n      let byte3 = load<u8>(inputOffset++) & 0x3f;\n      let byte4 = load<u8>(inputOffset++) & 0x3f;\n      let codepoint: i32 = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (codepoint > 0xffff) {\n        codepoint -= 0x10000;\n        store<u16>(outputOffset, ((codepoint >>> 10) & 0x3ff) | 0xd800);\n        outputOffset += u16s;\n        codepoint = 0xdc00 | (codepoint & 0x3ff);\n      }\n      store<u16>(outputOffset, codepoint);\n      outputOffset += u16s;\n    } else {\n      // invalid UTF-8\n      store<u16>(outputOffset++, byte1);\n      outputOffset += u16s;\n    }\n  }\n  return (outputOffset - outputPtr) / u16s;\n}\n","import { utf8CountUint16Array } from \"./utf8CountUint16Array\";\nimport { storeUint8BE, storeUint16BE, storeUint32BE, loadUint16BE } from \"./be\";\n\nfunction storeStringHeader(outputPtr: usize, utf8ByteLength: usize): usize {\n  let ptr = outputPtr;\n  if (utf8ByteLength < 32) {\n    // fixstr\n    storeUint8BE(ptr++, 0xa0 + (utf8ByteLength as u8));\n  } else if (utf8ByteLength < 0x100) {\n    // str 8\n    storeUint8BE(ptr++, 0xd9);\n    storeUint8BE(ptr++, utf8ByteLength as u8);\n  } else if (utf8ByteLength < 0x10000) {\n    // str 16\n    storeUint8BE(ptr++, 0xda);\n    storeUint16BE(ptr, utf8ByteLength as u16);\n    ptr += sizeof<u16>();\n  } else if ((utf8ByteLength as u64) < 0x100000000) {\n    // str 32\n    storeUint8BE(ptr++, 0xdb);\n    storeUint32BE(ptr, utf8ByteLength as u32);\n    ptr += sizeof<u32>();\n  } else {\n    throw new Error(`Too long string: ${utf8ByteLength} bytes in UTF-8`);\n  }\n  return ptr;\n}\n\n// outputPtr: u8*\n// inputPtr: u16*\n// It adds MessagePack str head bytes to the output\nexport function utf8EncodeUint16Array(outputPtr: usize, inputPtr: usize, inputLength: usize): usize {\n  let utf8ByteLength = utf8CountUint16Array(inputPtr, inputLength);\n  let strHeaderOffset = storeStringHeader(outputPtr, utf8ByteLength);\n\n  const u16s = sizeof<u16>();\n  let inputOffset = inputPtr;\n  let inputEnd = inputPtr + inputLength * u16s;\n  let outputOffset = strHeaderOffset;\n  while (inputOffset < inputEnd) {\n    let value: u32 = loadUint16BE(inputOffset);\n    inputOffset += u16s;\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      store<u8>(outputOffset++, value);\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      store<u8>(outputOffset++, ((value >> 6) & 0x1f) | 0xc0);\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (inputOffset < inputEnd) {\n          let extra: u32 = loadUint16BE(inputOffset);\n          if ((extra & 0xfc00) === 0xdc00) {\n            inputOffset += u16s;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        store<u8>(outputOffset++, ((value >> 12) & 0x0f) | 0xe0);\n        store<u8>(outputOffset++, ((value >> 6) & 0x3f) | 0x80);\n      } else {\n        // 4-byte\n        store<u8>(outputOffset++, ((value >> 18) & 0x07) | 0xf0);\n        store<u8>(outputOffset++, ((value >> 12) & 0x3f) | 0x80);\n        store<u8>(outputOffset++, ((value >> 6) & 0x3f) | 0x80);\n      }\n    }\n\n    store<u8>(outputOffset++, (value & 0x3f) | 0x80);\n  }\n\n  return outputOffset - outputPtr;\n}\n","import { loadUint16BE } from \"./be\";\n\n// inputPtr: u16*\nexport function utf8CountUint16Array(inputPtr: usize, inputLength: usize): usize {\n  const u16s = sizeof<u16>();\n\n  let byteLength: usize = 0;\n  let pos: usize = inputPtr;\n  let end = inputPtr + inputLength * u16s;\n  while (pos < end) {\n    let value: u32 = loadUint16BE(pos);\n    pos += u16s;\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < end) {\n          let extra: u32 = loadUint16BE(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            pos += u16s;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n","// load/store values in big-endian\n\nexport function loadFload32BE(byteOffset: usize): f32 {\n  return reinterpret<f32>(bswap<u32>(load<u32>(byteOffset)));\n}\n\nexport function loadFloat64BE(byteOffset: usize): f64 {\n  return reinterpret<f64>(bswap<u64>(load<u64>(byteOffset)));\n}\n\nexport function loadInt8BE(byteOffset: usize): i8 {\n  return load<i8>(byteOffset);\n}\n\nexport function loadInt16BE(byteOffset: usize): i16 {\n  return bswap<i16>(load<i16>(byteOffset));\n}\n\nexport function loadInt32BE(byteOffset: usize): i32 {\n  return bswap<i32>(load<i32>(byteOffset));\n}\n\nexport function loadInt64BE(byteOffset: usize): i64 {\n  return bswap<i64>(load<i64>(byteOffset));\n}\n\nexport function loadUint8BE(byteOffset: usize): u8 {\n  return load<u8>(byteOffset);\n}\n\nexport function loadUint16BE(byteOffset: usize): u16 {\n  return bswap<u16>(load<u16>(byteOffset));\n}\n\nexport function loadUint32BE(byteOffset: usize): u32 {\n  return bswap<u32>(load<u32>(byteOffset));\n}\n\nexport function loadUint64BE(byteOffset: usize): u64 {\n  return bswap<u64>(load<u64>(byteOffset));\n}\n\nexport function storeFloat32BE(byteOffset: usize, value: f32): void {\n  store<u32>(byteOffset, bswap<u32>(reinterpret<u32>(value)));\n}\n\nexport function storeFloat64BE(byteOffset: usize, value: f64): void {\n  store<u64>(byteOffset, bswap<u64>(reinterpret<u64>(value)));\n}\n\nexport function storeInt8BE(byteOffset: usize, value: i8): void {\n  store<i8>(byteOffset, value);\n}\n\nexport function storeInt16BE(byteOffset: usize, value: i16): void {\n  store<i16>(byteOffset, bswap<i16>(value));\n}\n\nexport function storeInt32BE(byteOffset: usize, value: i32): void {\n  store<i32>(byteOffset, bswap<i32>(value));\n}\n\nexport function storeInt64BE(byteOffset: usize, value: i64): void {\n  store<i64>(byteOffset, bswap<i64>(value));\n}\n\nexport function storeUint8BE(byteOffset: usize, value: u8): void {\n  store<u8>(byteOffset, value);\n}\n\nexport function storeUint16BE(byteOffset: usize, value: u16): void {\n  store<u16>(byteOffset, bswap<u16>(value));\n}\n\nexport function storeUint32BE(byteOffset: usize, value: u32): void {\n  store<u32>(byteOffset, bswap<u32>(value));\n}\n\nexport function storeUint64BE(byteOffset: usize, value: u64): void {\n  store<u64>(byteOffset, bswap<u64>(value));\n}\n","export function bswap<T>(value: T): T {\n  if (isInteger<T>()) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    }\n    if (sizeof<T>() == 4) {\n      return <T>(\n        rotl<u32>(<u32>value & 0xFF00FF00, 8) |\n        rotr<u32>(<u32>value & 0x00FF00FF, 8)\n      );\n    }\n    if (sizeof<T>() == 8) {\n      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n      let v = a | b;\n\n      a = (v >> 16) & 0x0000FFFF0000FFFF;\n      b = (v & 0x0000FFFF0000FFFF) << 16;\n\n      return <T>rotr<u64>(a | b, 32);\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n\n@inline\nexport function bswap16<T>(value: T): T {\n  if (isInteger<T>() && sizeof<T>() <= 4) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    } else if (sizeof<T>() == 4) {\n      return <T>(((value << 8) & <T>0xFF00) | ((value >> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n","import \"allocator/tlsf\";\n\nexport function malloc(size: usize): usize {\n  return memory.allocate(size);\n}\n\nexport function free(ptr: usize): void {\n  memory.free(ptr);\n}\n","import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n"]}